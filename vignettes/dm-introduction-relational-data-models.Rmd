---
title: "Introduction to Relational Data Models"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to Relational Data Models}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
fansi::set_knit_hooks(knitr::knit_hooks)
options(crayon.enabled = TRUE, width = 75, cli.width = 75)

knit_print.grViz <- function(x, ...) {
  x %>% 
    DiagrammeRsvg::export_svg() %>% 
    c("`````{=html}\n", ., "\n`````\n") %>% 
    knitr::asis_output()
}
```

Multiple, linked tables are a common concept within computer science. 
Since many R users have a background in other disciplines, we present **six important terms in relational data modeling** to jump-start working with {dm}.

It's good to have at least basic knowledge about the following terms:

1) [Tables](#tables)
2) [Data Model](#model)
3) [Primary Keys](#pk)
4) [Foreign Keys](#fk)
5) [Normalisation](#normalisation)
6) [Relational Databases](#relational-databases)

## 1. Tables

Users of the popular [{dplyr}](https://dplyr.tidyverse.org) package for data wrangling mainly rely on dataframes.
However, flat file systems like spreadsheets and dataframes can result in bloated tables, that hold many repetitive values.
Worst case, you have a dataframe with multiple columns and in each row only a single value is different.

This calls for a better data organization.
The separation into multiple tables is a first step that helps data quality.
But without an associated data model you don't take full advantage.

Let's illustrate this challenge with data from the [`nycflights13` dataset](https://github.com/hadley/nycflights13).
It contains detailed information of 336776 flights that departed from New York City in 2013.
The information is stored in five tables.

Details like the full name of an airport are not available immediately but must be joined/merged.
This can result in long and inflated pipe chains full of `left_join()`, `anti_join()` and other  forms of merging data.

In classical {dplyr} notation you need three `left_join()` calls to merge the `flights` table gradually to `airlines`, `planes` and `airports` tables to create one wide dataframe.

```{r warning=F, message=F}
library(tidyverse)
library(dm)
library(nycflights13)

flights %>% 
  left_join(airlines, by = "carrier") %>%
  left_join(planes, by = "tailnum") %>%
  left_join(airports, by = c("origin" = "faa"))
```

{dm} offers a more elegant and shorter way to combine tables while augmenting {dplyr}/{dbplyr} workflows.

You can have the best of both worlds: Manage your data with {dm} as linked tables, then flatten multiple tables into one for your analysis with {dplyr} on an as-needed basis.

The next step is to create a [data model](#model) based on multiple tables:

## 2. Data Model {#model}

A data model shows the structure between multiple tables, that can be linked together.

The `nycflights13` relations can be transferred into the following graphical representation:

```{r warning=F, message=F}
dm <- cdm_nycflights13(cycle = TRUE) 

dm %>% 
  cdm_draw()
```

The `flights` table is linked to three other tables: `airlines`, `planes` and `airports`.
By using directed arrows the visualization explicitly shows the connection between different columns (they are called attributes in the relational data sphere).

For example: The column `carrier` in `flights` can be joined with the column `carrier` from the `airlines` table.

The links between the tables are established through [primary keys](#pk) and [foreign keys](#fk).

Further Reading: The {dm} methods for [visualizing data models](https://krlmlr.github.io/dm/articles/dm-visualization.html).

## 3. Primary Keys {#pk}

In a relational data model every table needs to have **one column or attribute that uniquely identifies a row**.
This column is called primary key (abbreviated with pk).
A primary key can be either an existing column that satifies the condition of being unique or a new column that assigns an identifier.

Example: In the `airlines` table of `nycflights13` the column `carrier` is the primary key.

You can get all primary keys in a `dm` by calling `cdm_get_all_pks()`:

```{r}
dm %>%
  cdm_get_all_pks()
```

If an attribute is suitable as a primary key can be checked with `cdm_enum_pk_candidates()`.
Which columns of the `airlines` table can serve as a primary key?

```{r}
dm %>% 
  cdm_enum_pk_candidates(airports)
```

Further Reading: The {dm} package offers several function for dealing with [primary keys](https://krlmlr.github.io/dm/articles/dm-class-and-basic-operations.html#pk).

## 4. Foreign Keys {#fk}

The **counterpart of a primary key in one table is the foreign key in another table**.
In order to join two tables, the primary key of the first table needs to be available in the second table, too.
This second column is called the foreign key (abbreviated with fk).

For example: If you want to link the `airlines` table to the `flights` table, the primary key in `airlines` needs to match the foreign key in `flights`.
This is true, because the column `carrier` is present as a primary key in the `airlines` table as well as a foreign key in the `flights` table:

```{r}
dm %>% 
  cdm_get_fk(flights, airlines)
```


Further Reading: All {dm} functions for working with [foreign keys](https://krlmlr.github.io/dm/articles/dm-class-and-basic-operations.html#foreign-keys).

## 5. Normalisation {#normalisation}

Normalisation is the technical term that describes the **central design principle of a relational data model**:
splitting data into multiple tables.

A normalized data schema consists of several relations (tables) that are linked with attributes (columns).
The joining works with [primary](#pk) and [foreign keys](#fk).
One main goal is to keep the data organization as clean and simple as possible by avoiding redundant data entries.

For example: If you want to change the name of one airport in the `nycflights13` dataset, you have to update just a single data entry.
Sometimes, this principle is called "single point of truth".

```{r}
#  Update in one single location...
airlines[airlines$carrier == "UA", "name"] <- "United broke my guitar"

airlines %>%
  filter(carrier == "UA")

# ...propagates to all related records
flights %>%
  left_join(airlines) %>% 
  select(flight, name)
```

Another way to demonstrate normalisation is the function `decompose_table()`.
It splits one table into two.
Let's take the `planes` table and determine a new table containing the specified columns.
This results in a `parent_table` and a `child_table` containing the remaining columns, connected by surrogate keys, in this case `model_id`.

```{r}
planes %>% 
  decompose_table(model_id, model, manufacturer, type, engines, seats, manufacturer, speed)
```

Further Reading: See the [Simple English Wikipedia article on database normalisation](https://simple.wikipedia.org/wiki/Database_normalisation) for more details.

## 6. Relational Databases {#relational-databases}

{dm} is built upon relational data models, but it is not a database itself.
Databases are systems for data management and many of them are constructed as relational databases, e.g. SQLite, MySQL, MSSQL, Postgres.
As you can guess from the names of the databases SQL, short for **s**tructured **q**uerying **l**anguage, plays an important role: It was invented for the purpose of querying relational databases.

In production, the data is stored in a relational database and {dm} is used to work with the data.

Therefore, {dm} can copy data [from and to databases](https://krlmlr.github.io/dm/articles/dm.html#copy), and works transparently with both in-memory data and with relational database systems.

For example, let's create a local Sqlite database and copy the `dm` object to it:
```{r}
src_sqlite <- src_sqlite(":memory:", create = TRUE)
src_sqlite
cdm_copy_to(src_sqlite, dm)
src_sqlite
```

In the opposite direction, `dm` can also be populated with data from a DB. Unfortunately, this currently works just for MSSQL and Postgres, but not for Sqlite.
Therefore, we cannot show the results here yet:

```{r eval=FALSE}
cdm_learn_from_db(src_sqlite)
```
