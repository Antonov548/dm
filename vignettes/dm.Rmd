---
title: "Getting Started"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

``````{r setup, include = FALSE}
source("setup/setup.R")
``````

## Introduction

The goal of this article is to introduce you to the most common operations you will perform with {dm} by demonstrating how easy it is to move from accessing relational data to producing results with it.
As such it is low on details and caveats, but links are provided throughout to more detailed documnentation.  

## Creating a dm object

dm objects can be created from individual tables or loaded directly from a relational data model on an RDBMS. 
For this introduction we are going work with a model hosted on a public server. 

The first thing we need is a connection to the RDBMS hosting the data.

``````{r }
library(RMariaDB)

fin_db <- dbConnect(
  MariaDB(),
  username = 'guest',
  password = 'relational',
  dbname = 'Financial_ijs',
  host = 'relational.fit.cvut.cz'
)
``````

We create a dm object from an RDBMS using `dm_from_src()`, passing in the connection object as the first argument.

``````{r message = FALSE}
library(dm)

fin_dm <- dm_from_src(fin_db)
fin_dm
``````

The dm object interrogates the RDBMS for table and column information and, where implemented, primary and foreign keys. 
Currently, primary and foreign keys are only available from Postgres and MSSQL servers. 

## Linking tables by adding keys

The public RDBMS is a MariaDB, which does not provide key metadata.
As a result the visualization results in a series of boxes containing just the table names. 
The lack of keys is easily fixed.
We can define primary and foreign keys ourselves.

```{r keys}

fin_dm_keys <-
  fin_dm %>%
  dm_add_pk(accounts, id) %>%
  dm_add_pk(loans, id) %>%
  dm_add_fk(loans, account_id, accounts) %>%
  dm_add_pk(trans, id) %>%
  dm_add_fk(trans, account_id, accounts) %>%
  dm_add_pk(districts, id) %>%
  dm_add_fk(accounts, district_id, districts)
```

## Visualizing a data model

We can display a visual summary of the dm.
The default is to display the table name and any defined keys.

FIXME

Visualizing the dm in its current state we now see the keys we have created and how they link the tables together.

```{r visualize_keys}

fin_dm_keys %>%
  dm_set_colors(green = loans, orange = accounts, red = trans, grey = districts) %>%
  dm_draw()

```

## Accessing a data model as a table

If we want to perform modeling or analysis on this relational model we need to transform it into a tabular format that R functions can work with. 
`dm_flatten_to_tbl()` will automatically follow foreign keys across tables to gather all the available columns into a single table.

```{r flatten}

fin_dm_keys %>%
  dm_flatten_to_tbl(loans)

```

## Operations on table data

We don't need to export the data to perform operations it.
Through the dm object we have complete access to dplyr's data manipulation verbs.
These operate on the data within individual tables.

To work with a particular table we use `dm_zoom_to()` to set the context to our chosen table.

```{r zoom}
fin_dm_total <-
  fin_dm_keys %>%
  dm_zoom_to(loans) %>%
  group_by(account_id) %>%
  summarize(total_amount = sum(amount, na.rm = TRUE)) %>%
  ungroup() %>%
  dm_insert_zoomed("total_loans")

fin_dm_total$total_loans

```

Note that in the above example we use `dm_insert_zoomed()` to add the new table to our data model.
This table is temporary and will be deleted when our session ends.
If you want to make permanent changes to your data model please see the documentation on [Persistence](#FIXME).

## Checking constraints

It's always smart to check that your data model follows its specifications.
When building our own model, or changing existing models by adding tables or keys, it is even more important that the new model is validated.

`dm_examine_constrains()` checks all primary and foreign keys and reports if they violate their expected constraints.

```{r constraints}
fin_dm_total %>% 
  dm_examine_constraints()
```

For more on constraint checking, including cardinality and finding candidate columns for keys, see the [Constraint](#FIXME) documentation.

## Next Steps


- immediate next steps?

- further reading: comprehensive list of all articles, one paragraph per article, with link

- standing on the shoulders of giants, full version?

END FIXME

An object of the `dm` class contains the data in the tables, and metadata about the tables, such as

- the names of the tables
- the names of the columns of the tables
- the key constraints to link the tables together
- the data (either as data frames or as references to database tables)

This package augments [{dplyr}](https://dplyr.tidyverse.org/)/[{dbplyr}](https://dbplyr.tidyverse.org/) workflows:

- multiple related tables are kept in a single compound object
- joins across multiple tables are available by specifying the tables involved, without a need to memorize column names or relationships

In addition, a battery of utilities is provided that helps with creating a tidy data model.

This package follows several of the "tidyverse" rules:

- `dm` objects are immutable (your data will never be overwritten in place)
- many functions used on `dm` objects are pipeable (i.e., return new `dm` objects)
- tidy evaluation is used (unquoted function parameters are supported)

The {dm} package builds heavily upon the [{datamodelr} package](https://github.com/bergant/datamodelr), and upon the [tidyverse](https://www.tidyverse.org/).
We're looking forward to a great collaboration!

We will now demonstrate some of the features of {dm}:

1. [Creation of `dm` objects](#create)
1. [Setting keys and drawing](#keys)
1. [Filtering](#filter)
1. [Copying and discovery](#copy)

Let's first have a brief look at how to create a `dm`-class object.

```{r message=FALSE}
library(tidyverse)
library(dm)
```


## Creating `dm` objects: {#create}

The [{nycflights13}](https://github.com/hadley/nycflights13) package offers a nice example of interconnected tables.
The most straightforward way of squeezing those tables into a `dm` object is:

```{r message=FALSE}
flights_dm <- dm_from_src(src_df(pkg = "nycflights13"))
flights_dm
```

This fairly verbose output shows the data and metadata of a `dm` object.
The various components can be accessed with functions of the type `dm_get_...()`, e.g.:

```{r}
dm_get_src(flights_dm)
dm_get_all_pks(flights_dm)
dm_get_all_fks(flights_dm)
```

Notably, the function `dm_get_tables()` returns a named list containing the individual tables.

## Keys and visualization {#keys}

As you can see in the output above, no keys have been set so far.
We will use `dm_add_pk()` and `dm_add_fk()` to add primary keys (pk) and foreign keys (fk):

```{r}
flights_dm_with_one_key <- 
  flights_dm %>% 
  dm_add_pk(airlines, carrier) %>% 
  dm_add_fk(flights, carrier, airlines)
```

After you set the keys and establish relations, you can create a graphical representation of your data model with `dm_draw()`:

```{r}
flights_dm_with_one_key %>% 
  dm_draw()
```

The `dm_nycflights13()` function provides a shortcut: the `dm` object returned by this function contains all tables (by default a reduced version of table `flights`), defines all primary and foreign keys, and even assigns colors to the different types of tables.
We will be using the `dm` object created by this function from now on.

```{r}
flights_dm_with_keys <- dm_nycflights13(cycle = TRUE)
flights_dm_with_keys %>% 
  dm_draw()
```


## Filtering a table of a `dm` object {#filter}

The idea of a filter on a `dm` object:

1. You can filter one or more of `dm`'s tables, just like with normal `dplyr::filter()` calls
1. Filtering conditions are immediately executed for the table in question and additionally stored in the `dm` object
1. If you access a table via `dm_apply_filters_to_tbl()`, a sequence of `semi_join()` calls is performed to retrieve the requested table with only those values in the key columns which correspond to the remaining values in the filtered tables

The function `dm_apply_filters()` essentially calls `dm_apply_filters_to_tbl()` for each table of the `dm` and creates a new `dm` object from the result.

Currently, this only works if the graph induced by the fk relations is cycle free, the default for `dm_nycflights13()`:

```{r}
flights_dm_acyclic <- dm_nycflights13()
flights_dm_acyclic %>% 
  dm_draw()
```

Let's set two filters:

```{r}
us_flights_from_jfk_prepared <- 
  flights_dm_acyclic %>%
  dm_filter(airports, name == "John F Kennedy Intl") %>% 
  dm_filter(airlines, name == "US Airways Inc.")
us_flights_from_jfk_prepared
```

With `dm_apply_filters()`, you can apply all filters and therefore update all tables in the `dm`, so that they contain only the rows that are relevant to the filters. 
The effect of the filters can be seen when counting the rows:

```{r}
us_flights_from_jfk <- dm_apply_filters(us_flights_from_jfk_prepared)
us_flights_from_jfk %>% 
  dm_get_tables() %>% 
  map_int(nrow)
```

Alternatively, you can just pull out one of the tables from `dm` to answer the question which planes were used to service the US Airways flights that departed from JFK airport:

```{r}
dm_apply_filters_to_tbl(us_flights_from_jfk, "planes")
```

Each of the planes in the result set above was a part of at least one US Airways flight departing from JFK.
Do they have any common characteristics?

```{r}
dm_apply_filters_to_tbl(us_flights_from_jfk, "planes") %>% 
  count(model)
```

For comparison, let's look at the equivalent manual query in {dplyr} syntax:

```{r eval=FALSE}
flights %>% 
  left_join(airports, by = c("origin" = "faa")) %>% 
  filter(name == "John F Kennedy Intl") %>%
  left_join(airlines, by = "carrier") %>% 
  filter(name.y == "US Airways Inc.") %>%
  semi_join(planes, ., by = "tailnum") %>% 
  count(model)
```

The {dm} code is leaner because the foreign key relations are encoded in the object.

Mind, that if you access a table via `tbl.dm()`, `$.dm()` or `[[.dm()`, filter conditions set for other tables are ignored.

### Joining two tables {#join}

The `dm_join_to_tbl()` function joins two immediately related tables in a data model.
The definition of the primary and foreign key constraints is used to define the relationship.

```{r}
flights_dm_with_keys %>%
  dm_join_to_tbl(airlines, flights, join = left_join)
```

The same operation using {dplyr} syntax looks like this:

```{r eval=FALSE}
library(nycflights13)
airlines %>% 
  left_join(flights, by = "carrier")
```

Omitting the `by` argument leads to a warning.

## Copy a `dm` object to a DB or learn from it {#copy}

`dm` objects can be transferred from one `src` to another.
The relevant verb is `copy_dm_to()`, which will copy both data and key constraints.

```{r}
src_sqlite <- src_sqlite(":memory:", create = TRUE)
src_sqlite
flights_dm_with_keys_remote <- copy_dm_to(src_sqlite, flights_dm_with_keys)
```

As a result, the tables are transferred to the target data source, and all keys will be contained in the returned data model.

```{r}
src_sqlite
flights_dm_with_keys_remote
```

In the opposite direction, `dm` objects can also be "learned" from a DB, including the key constraints, by utilizing the DB's meta-information tables.
Unfortunately, this currently only works for MSSQL and Postgres, so we cannot show the results here just yet:

```{r eval=FALSE}
flights_dm_from_remote <- dm_learn_from_db(src_sqlite)
```

## Further reading

- Learn other ways of creating `dm` objects and basic operations on them, like handling key constraints in the ["Class 'dm' and basic operations"](https://krlmlr.github.io/dm/articles/dm-class-and-basic-operations.html) article
- All about the possibilities of graphic representations of `dm` objects: the ["Visualizing 'dm' objects"](https://krlmlr.github.io/dm/articles/dm-visualization.html) article
- Constraints, cardinalities, and normalization: the ["Low level operations"](https://krlmlr.github.io/dm/articles/dm-low-level.html) article
