---
title: "Getting Started"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
fansi::set_knit_hooks(knitr::knit_hooks)
options(crayon.enabled = TRUE, width = 75, cli.width = 75)

knit_print.grViz <- function(x, ...) {
  x %>% 
    DiagrammeRsvg::export_svg() %>% 
    c("`````{=html}\n", ., "\n`````\n") %>% 
    knitr::asis_output()
}
```

The goal of both the package {dm} and its `dm` class is to facilitate work with multiple related tables.
An object of the `dm`-class contains all relevant information about the tables in a data model:

1. the place where the tables live (i.e., the `src`: a database (DB) or locally in your R session)
1. the meta-data from the data model: the tables, columns, and key constraints
1. the data in the tables

This package follows several of the "tidyverse" rules:

- `dm` objects are immutable (your data will never be overwritten in place)
- many functions used on `dm` objects are pipeable (i.e., return new `dm` objects)
- tidy evaluation is used (unquoted function parameters are supported)

We will showcase here some of the features of {dm}:

1. [Creation of `dm` objects](#create)
1. [Setting keys and drawing](#keys)
1. [Filtering](#filter)
1. [Copying and discovery](#copy)

Let's first have a brief look at how to create a `dm`-class object.

```{r message=FALSE}
library(dm)
library(tidyverse)
```


## Creating `dm` objects: {#create}

The {nycflights13}-package offers a nice example for interconnected tables.
The most straightforward way of squeezing them into a `dm` object is:

```{r message=FALSE}
flights_dm <- dm(src_df(pkg = "nycflights13"))
flights_dm
```

The fairly verbose output shows the three components of a `dm` object: the table source, the metadata, and row counts.
These components can be accessed with `cdm_get_src()`, `cdm_get_tables()` and `cdm_get_data_model()`.

```{r}
cdm_get_src(flights_dm)
# Quering nrow() for each table, to suppress otherwise huge output
map_int(cdm_get_tables(flights_dm), nrow)
cdm_get_data_model(flights_dm)
```


## Keys and visualization {#keys}

As you can see in the "Data model" part of the output above, so far no keys are set.
We use `cdm_add_pk()` and `cdm_add_fk()` to add primary keys (pk) and foreign keys (fk):

```{r}
flights_dm_with_one_key <- 
  flights_dm %>% 
  cdm_add_pk(airlines, carrier) %>% 
  cdm_add_fk(flights, carrier, airlines)
```

Once you set the pk's and established fk relations, you can graphically represent your data model in the following way:

```{r}
flights_dm_with_one_key %>% 
  cdm_draw()
```

The `cdm_nycflights13()` function provides a shortcut: the `dm` object returned by this function contains all tables and defines all primary and foreign keys.
We will be using the `dm` object created by this function from here on.

```{r}
flights_dm_with_keys <- cdm_nycflights13()
flights_dm_with_keys %>% 
  cdm_draw()
```


## Filtering a table of a `dm` object {#filter}

The idea of a filter on a `dm` object:

1. You filter one table of your `dm`, just like with a normal `dplyr::filter()` call
2. A cascade of joins is performed along the fk relations, resulting in a new `dm` containing only rows related to the filter operation

Currently, this only works if the graph induced by the fk relations is cycle free.
Our `cdm_nycflights13()` helper has an option for this:

```{r}
flights_dm_acyclic <- cdm_nycflights13(cycle = FALSE)
flights_dm_acyclic %>% 
  cdm_draw()
```

Let's see it in action:

```{r}
us_flights_from_jfk <- 
  flights_dm_acyclic %>%
  cdm_filter(airports, name == "John F Kennedy Intl") %>% 
  cdm_filter(airlines, name == "US Airways Inc.")
us_flights_from_jfk
```

In the "Rows" part of the print-output, you can observe the reduction in the numbers of rows for all tables (apart from the -- disconnected -- `weather` table), corresponding to US Airways flights having started from JFK airport.

Which planes were used to service these flights?

```{r}
tbl(us_flights_from_jfk, "planes")
```

Each of the planes in the result set above was part in at least one United flight departing from JFK.
Do they have common characteristics?

```{r}
tbl(us_flights_from_jfk, "planes") %>% 
  count(model)
```

For comparison, let's review the equivalent manual query in {dplyr} syntax:

```{r eval=FALSE}
flights %>% 
  left_join(airports, by = c("origin" = "faa")) %>% 
  filter(name == "John F Kennedy Intl") %>%
  left_join(airlines, by = "carrier") %>% 
  filter(name.y == "US Airways Inc.") %>%
  semi_join(planes, ., by = "tailnum") %>% 
  count(model)
```

The {dm} code is leaner, because the fk information is encoded in the object.


## Copy a `dm` object to a DB or learn from it {#copy}

`dm` objects can be transferred from one `src` to another.
The relevant verb is `cdm_copy_to()`, which will copy both data and key constraints.

```{r}
src_sqlite <- src_sqlite(":memory:", create = TRUE)
src_sqlite
flights_dm_with_keys_remote <- cdm_copy_to(src_sqlite, flights_dm_with_keys)
```

As a result, the tables are transferred to the target data source, and the returned data model contains all keys.

```{r}
src_sqlite
flights_dm_with_keys_remote
```

In the opposite direction, `dm` objects can also be "learned" from a DB, including the key constraints, by utilizing the DB's meta-information tables.
Unfortunately, this currently works only for MSSQL and Postgres, we cannot show the results here yet:

```{r eval=FALSE}
flights_dm_from_remote <- cdm_learn_from_db(src_sqlite)
```

## Further reading

FIXME Kirill:

Further functions that are helpful in organizing the keys of a `dm` object are able to e.g. show you, which columns are set as key columns, remove key constraints, etc.
More details can be found in the documentation of the relevant functions.

There are a few options of customizing the way, the data model is displayed, e.g. add different colors to subsets of the tables or arrange the tables in a different way.
You can find details about this in the documentation or in the vignette "Visualizing 'dm'-objects".

It will copy the individual tables from the former to the new `src`, potentially set key constraints -- if on a DB (so far only MSSQL and Postgres are supported for this feature) -- and subsequently invisibly return the new `dm` object.

Here we show an example using the in-memory SQLite-DB (so no key constraints are established):

it is not possible to execute the corresponding code in this vignette, since -- just like with the transfer to a DB -- only MSSQL and Postgres are so far supported, and there are no generally accessible DBs of this type available.

But anyhow, we can show, how the code looks like


### Joining two tables {#join}

The `cdm_join_tbl()` function joins two immediately related tables in a data model.
The definition of the primary and foreign key constraints is used to define the relationship.

```{r}
flights_dm_with_keys %>%
  cdm_join_tbl(airlines, flights, join = left_join)
```

The same operation using {dplyr} syntax looks like this:

```{r eval=FALSE}
library(nycflights13)
airlines %>% 
  left_join(flights, by = "carrier")
```

Omitting the `by` argument leads to a warning
