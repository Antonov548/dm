---
title: "Persisting data models with dm"
author: "James Wondrasek"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{How to: Create a dm object from a database}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---


``````{r setup, include = FALSE}
source("setup/setup.R")
``````

# Working with databases

A dm object can be created from any database that has a {[DBI](https://dbi.r-dbi.org/)} backend ([see list](https://github.com/r-dbi/backends)).
When a dm object is created it can either import all the tables in the database, the active schema or a limited set.
For some RDBMS, such as Postgres and SQL Server, primary and foreign keys are also imported and do not have to be manually added afterwards.

To demonstrate, we connect to a [relational dataset repository](https://relational.fit.cvut.cz/) with a database server that is publicly accessible without registration.
There is a [financial dataset](https://relational.fit.cvut.cz/dataset/Financial) that contains loan data along with relevant account information and transactions.
We chose this dataset because the relationships between `loan`, `account`, `transactions` tables are a good representation of databases that record real-world business transactions.
The repository uses a MariaDB server for which {dm} does not currently import primary or foreign keys, so we will need to add them.

``````{r }
library(RMariaDB)
my_db <- dbConnect(
  MariaDB(),
  username = 'guest',
  password = 'relational',
  dbname = 'Financial_ijs',
  host = 'relational.fit.cvut.cz'
)
``````

Creating a dm object takes a single call to `dm_from_src()` with the DBI connection object as its argument.

``````{r message = FALSE}
library(dm)

my_dm <- dm_from_src(my_db)
my_dm
``````

The components of the `my_dm` object are lazy tables powered by {[dbplyr](https://dbplyr.tidyverse.org/)}.
{dbplyr} translates the {[dplyr](https://dplyr.tidyverse.org/)} grammar of data manipulation into queries the database server understands.
Lazy tables defer downloading of table data until results are required for printing or local processing.

## Building a dm from a subset of tables

A dm can also be constructed from individual tables or views.
This is useful for when you want to work with a subset of a database's tables, perhaps from different schemas.

Below we use the `tbl()` function from {dplyr} to extract two tables from the financial database.
Then we create our dm by passing the tables in as arguments.
Note that the tables arguments have to all be from the same source.

``````{r }
dbListTables(my_db)

library(dbplyr)
loans <- tbl(my_db, "loans")
accounts <- tbl(my_db, "accounts")

my_manual_dm <- dm(loans, accounts)
my_manual_dm
``````

## Define Primary and Foreign Keys

Primary keys and foreign keys are how relational database tables are linked with each other.
A primary key is a column that has a unique value for each row within a table.
A foreign key is a column containing the primary key for a row in another table.[^compound]
Foreign keys act as cross references between tables.
They specify the relationships that gives us the *relational* database.

[^compound]: Support for compound keys (consisting of multiple columns) is [planned](https://github.com/krlmlr/dm/issues/3).

The [model diagram](https://relational.fit.cvut.cz/assets/img/datasets-generated/financial.svg) provided by our test database loosely illustrates the intended relationships between tables.
In the diagram we can see that the `loans` table should be linked to the `accounts` table.
Below we create those links in 3 steps:

1. Add a primary key `id` to the `accounts` table
1. Add a primary key `id` to the `loans` table
1. Add a foreign key `account_id` to the `loans` table referencing the `accounts` table

Then we assign colors to the tables and draw the structure of the dm.

Note that when the foreign key is created the primary key in the referenced table does not need to be specified, but the primary key must already be defined.
And, as mentioned above, primary and foreign key constraints on the database are currently only imported for Postgres and SQL Server databases, and only when `dm_from_src()` is used.
This process of key definition needs to be done manually for other databases.

``````{r }
my_dm_keys <-
  my_manual_dm %>%
  dm_add_pk(accounts, id) %>%
  dm_add_pk(loans, id) %>%
  dm_add_fk(loans, account_id, accounts) %>%
  dm_set_colors(green = loans, orange = accounts)

my_dm_keys %>%
  dm_draw()
``````

Once you have instantiated a dm object you can continue to add tables to it.
For tables from the original source for the dm, use `dm_add_tbl()`

``````{r }
trans <- tbl(my_db, "trans")

my_dm_keys %>%
  dm_add_tbl(trans)
``````

For tables from other sources or from the local environment `dplyr::copy_to()` is used.
`copy_to()` is discussed later in this article.

## Transient nature of operations

Like other R objects, a dm is immutable and all operations performed on it are transient unless stored in a new variable.

``````{r }
my_dm_keys

my_dm_trans <-
  my_dm_keys %>%
  dm_add_tbl(trans)

my_dm_trans
``````

And, like {dbplyr}, results are never written to a database unless explicitly requested.

``````{r }
my_dm_keys %>%
  dm_flatten_to_tbl(loans)

my_dm_keys %>%
  dm_flatten_to_tbl(loans) %>%
  sql_render()
``````

## Performing operations on tables by "zooming"

As the dm is a collection of tables, if we wish to perform operations on an individual table we set it as the context for those operations using `dm_zoom_to()`.
See `vignette("tech-dm-zoom")` for more detail on zooming.

dm operations are transient unless persistence is explicitly requested.
To make our chain of manipulations on the selected table permanent we assign the result of `dm_insert_zoomed()` to a new object, `my_dm_total`.
This is a new dm object, derived from `my_dm_keys`, with a new lazy table `total_loans` linked to the `accounts` table.
The subsequent section describes how to materialize the results on the database.

``````{r }
my_dm_total <-
  my_dm_keys %>%
  dm_zoom_to(loans) %>%
  group_by(account_id) %>%
  summarize(total_amount = sum(amount, na.rm = TRUE)) %>%
  ungroup() %>%
  dm_insert_zoomed("total_loans")

my_dm_total$total_loans

my_dm_total %>%
  dm_draw()

my_dm_total$total_loans %>%
  sql_render()
``````


## Persisting results {#persist}

After adding columns to link tables or calculate summaries of data, we might want these changes to the database to persist.

To force a dm to execute the SQL query generated by the operations it has performed, we call the `dplyr::compute()` method on the dm object.

`compute()` forces the computation of a query, in this case the query or multiple queries created by the dm to represent all operations that have been performed but not yet evaluated.
The results of `compute()` are stored in temporary tables on the database server and will be deleted when your session ends.
If you want results to persist across sessions in permanent tables, `compute()` must be called with the argument `temporary = FALSE` and a table name for the `name` argument.
See the `compute()` documentation for more details.

Calling `compute()` requires write access, otherwise an error is returned.
Our example RDBMS, relational.fit.cvut.cz, does not allow write access.
As a workaround to demonstrate the usage of `compute()`, we will use `dm_financial_sqlite()`, a convenience function that handles the copying of the dm from the remote RDBMS to a local SQLite database we can write to.

``````{r }
my_dm_sqlite <- dm_financial_sqlite()

my_dm_total <-
  my_dm_sqlite %>%
  dm_zoom_to(loans) %>%
  group_by(account_id) %>%
  summarize(total_amount = sum(amount, na.rm = TRUE)) %>%
  ungroup() %>%
  dm_insert_zoomed("total_loans")
``````

Two {[dplyr](https://dplyr.tidyverse.org/)} verbs have been implemented for dm objects.
`compute()`, as mentioned above, materializes all tables into new (temporary or persistent) tables.

``````{r }
my_dm_total_computed <-
  my_dm_total %>%
  compute()

my_dm_total_computed$total_loans

my_dm_total_computed$total_loans %>%
  sql_render()
``````

`collect()` downloads all tables to local data frames.

``````{r }
my_dm_local <-
  my_dm_total %>%
  collect()

my_dm_local$total_loans
``````

There is a third {dbplyr} verb that has not yet been implemented.
`collapse()` forces generation of the SQL query instead of computation ([#304](https://github.com/krlmlr/dm/issues/304)).

`compute()` also works for a zoomed dm.
Calling it during a chain of operations will execute all relevant SQL queries up to that point.
Operations after the `compute()` will use the generated results.


``````{r }
my_dm_total_inplace <-
  my_dm_sqlite %>%
  dm_zoom_to(loans) %>%
  group_by(account_id) %>%
  summarize(total_amount = sum(amount, na.rm = TRUE)) %>%
  ungroup() %>%
  compute() %>%
  dm_insert_zoomed("total_loans")

my_dm_total_inplace$total_loans %>%
  sql_render()
``````


## Populating a dm with data

While you will often create your dm objects from existing data frames or databases, you may need to add new data to an existing source or change in place data that is already present.
We will now look at how to accomplish this using dm.

## Inserting new data

`dm_rows_insert()` adds new rows (like SQL's `INSERT`).
Its first argument is the table the new rows are to be inserted into.
The second argument is a table containing the rows to be inserted.
These two tables are expected to be compatible, i.e. have the same columns, and also be on the same data source. 
The primary key values in the rows to be inserted cannot be present in the destination table.
IF any duplicate keys are present no rows will be inserted and the method will exit withan error message.

#' `dm_rows_insert()` adds new records via [rows_insert()].
#' The primary keys must differ from existing records.
#' This must be ensured by the caller and might be checked by the underlying database.
#' Use `in_place = FALSE` and apply [dm_examine_constraints()] to check beforehand.

#'    not occur in `x`.
these operations may lead to irreversible changes to the underlying database.
#' Therefore, in-place updates must be requested explicitly with `in_place = TRUE`.
#' By default, an informative message is given.
#' Unlike [compute()] or [copy_to()], no new tables are created.

## Updating existing data

`dm_rows_update()` changes the column values in existing rows in a table (like SQL's `UPDATE`).
Its first argument is the original table with rows that need updating.
The second argument is the working table containing the rows that need updating.
These two tables must be compatible, i.e. have the same columns, and also be on the same data source.
The primary keys of the rows in the working table must match the primary keys in the original table.
If any rows in the working table do not match a primary key in the original table then the method will fail with an error message and no rows will be updated.


#' `dm_rows_update()` updates existing records via [rows_update()].
#' Primary keys must match for all records to be updated.
#'
