---
title: "Copying a dm into an RDBMS"
date: "`r Sys.Date()`"
author: James Wondrasek, Kirill MÃ¼ller
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{How to: Create a dm object from a database}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---


``````{r setup, include = FALSE}
source("setup/setup.R")
``````

## Persisting results {#persist}

so intro. copying a dm. this falls under the general umbrella of persisting results. 
In this tutorial we run through techniques for persisting entire tables and an entire relational model. 
In the next tutorial, `vignette("howto-dm-update")`, adding and updating at the granularity of individual rows is covered.

Adding columns to link tables, or creating tables to hold summaries of data, even temporary ones, requires write access to the source RDBMS.
Because of this, the examples in this tutorial will use SQLite and all operations will be executed locally. 
Performing the same operations on a remote server would be done exactly the same/.

In this tutorial we will use the dm convenience function `dm_financial_sqlite()` that handles the copying of the dm from the remote RDBMS in the previous tutorial, `vignette("howto-dm-load")`, to a local SQLite database we can write to.

``````{r }
my_dm_sqlite <- dm_financial_sqlite()

my_dm_sqlite
``````

## Persisting tables using `compute()`

After adding columns to create links between tables or adding tables when we calculate summaries of data, we might want these changes to our data model to persist.

To force a dm to execute the SQL query generated by the operations it has performed, we call the `dplyr::compute()` method on the dm object.

`compute()` forces the computation of a query.  in this case the query or multiple queries created by the dm to represent all operations that have been performed but not yet evaluated.
The results of `compute()` are stored in temporary tables on the database server and will be deleted when your session ends.
If you want results to persist across sessions in permanent tables, `compute()` must be called with the argument `temporary = FALSE` and a table name for the `name` argument.
See the `compute()` documentation for more details.

Calling `compute()` requires write access, otherwise an error is returned.

We start this example by creating a summary table that totals the loans for each account.

``````{r }
my_dm_total <-
  my_dm_sqlite %>%
  dm_zoom_to(loans) %>%
  group_by(account_id) %>%
  summarize(total_amount = sum(amount, na.rm = TRUE)) %>%
  ungroup() %>%
  dm_insert_zoomed("total_loans")

my_dm_total$total_loans
``````

Context is set to the table "loans" using `dm_zoom_to(loans)`.
You can learn more about zooming in the tutorial `vignette("tech-dm-zoom")`.
We then use {[dplyr](https://dplyr.tidyverse.org/)} functions on the zoomed table to generate a new summary table.

`summarize()` returns a temporary table with one row for each group created by the preceding `group_by()` function.
The columns in the temporary table are constrained to the columns passed as arguments to the `group_by()` function and the column(s) created by the `summarize()` function.  

`dm_insert_zoomed("total_loans")` adds the temporary table to our data model under a new name.

Two {[dplyr](https://dplyr.tidyverse.org/)} verbs have been implemented for dm objects.
`compute()`, as mentioned above, materializes all tables into new (temporary or persistent) tables.

``````{r }
my_dm_total_computed <-
  my_dm_total %>%
  compute()

my_dm_total_computed$total_loans

#FIXME: do we need to add library(dbplyr) to run this? I had to from the console when I was 
my_dm_total_computed$total_loans %>%
  sql_render()

my_dm_total$total_loans %>%
  sql_render()

``````


`compute()` also works for a zoomed dm.
Calling it during a chain of operations will execute all relevant SQL queries up to that point.
Operations after the `compute()` will use the generated results.


``````{r }
my_dm_total_inplace <-
  my_dm_sqlite %>%
  dm_zoom_to(loans) %>%
  group_by(account_id) %>%
  summarize(total_amount = sum(amount, na.rm = TRUE)) %>%
  ungroup() %>%
  compute() %>%
  dm_insert_zoomed("total_loans")

my_dm_total_inplace$total_loans %>%
  sql_render()
``````


## Persisting a data model

Using dm you can persist an entire data model with a single function call, or piece by piece.
`copy_dm_to()` will move your entire data model into a destination RDBMS.
This may be all you need to deploy a new data model.
Considerations on which approach to use depend on a number of factors. 
For newly created data models those factors are the size of your data model and network bandwidth.
For data models that are updates to existing models on an RDBMS, deciding factors are the size of the changes and their complexity. 

For the rest of this tutorial we will demonstrate persisting an entire data model. 
For finer-grained control over persisting a data model, including updating specific tables and rows, see the next tutorial `vignette("howto-dm-rows")`.

## Persisting a data model with `copy_dm_to()`

To demonstrate persisting a data model we will use an SQLite database.
Moving our data model into the database takes a single functional call. 
Note that we pass in the argument `temporary = FALSE`. 
Without this argument our data model would still be copied into the database, but it would be deleted once our session ends. 

``````{r }
sqlite_db <- DBI::dbConnect(RSQLite::SQLite())

dm_deployed <-
  copy_dm_to(sqlite_db, my_dm_total_computed, temporary = FALSE)

dm_deployed

``````

Copying a data model into an empty database is the simplest use case for `copy_dm_to()`.
If you want to copy a data model into an RDBMS that is already populated, be aware that `copy_dm_to()` will not overwrite pre-existing tables.
You will need to use the `table_names` argument to give the tables unique names.
The argument can be a named character vector, with the names matching the table names in the dm object and the values containing the desired names in the RDBMS.
`table_names` may also be a function or one-sided formula.

``````{r }
dm_dup <-
  copy_dm_to(sqlite_db, my_dm_total_computed, temporary = FALSE, table_names = ~ paste0("dup_", .x))

dm_dup
dm_dup$accounts
dm_deployed$accounts

``````

Note the first line of the output for `dm_dup$accounts`.
The table name is `accounts` in the dm but it is backed by the table `dup_accounts` in the RDBMS.
`dm_deployed$accounts` shows us that this table is still backed by the `accounts` table from the `copy_dm_to()` operation we performed in the preceding example.
Managing tables in the RDBMS is outside the scope of `dm`. 
If you find you need to remove tables or perform operations directly on the RDBMS, see the {DBI} package.

## Conclusion

`dm` makes it straightforward to deploy your complete relational model to an RDBMS using the `copy_dm_to()` function.







