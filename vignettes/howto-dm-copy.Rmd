---
title: "Copying a dm into an RDBMS"
date: "`r Sys.Date()`"
author: James Wondrasek, Kirill MÃ¼ller
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{How to: Create a dm object from a database}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---


``````{r setup, include = FALSE}
source("setup/setup.R")
``````


In this tutorial we run through techniques for persisting an entire relational model as well as individual tables.
For modifying and persisting changes to your relational model at the row-level see `vignette("howto-dm-rows")`.

## Copying a complete relational model

Using {dm} you can persist an entire relational model with a single function call or piece by piece.
`copy_dm_to()` will move your entire model into a destination RDBMS.
This may be all you need to deploy a new data model.
Considerations for which approach to use depend on a number of factors. 
For newly created relational models those factors are the size of your model and network bandwidth.
For models that are updates to existing models on an RDBMS, deciding factors are the size of the changes and their complexity. 

## Persisting a relational model with `copy_dm_to()`

To demonstrate persisting a model we will use an SQLite database.
Persistence, because it is intended to make permanent changes, requires write access to the source RDBMS.
To enable you to execute the examples in this tutorial SQLite will be used and all operations will be performed locally. 
{dm} is designed so there is no difference between the code used to manipulate a local SQLite database and a remote RDBMS.

To create a relational model we will use the dm convenience function `dm_financial()` used in the previous tutorial, `vignette("howto-dm-load")`, followed by `collect()`, which retrieves all tables and returns them as a local dm object.
Before downloading, the `trans` table is excluded due to its size.

``````{r }
library(dm)
library(dplyr)
library(dbplyr)

fin_dm <-
  dm_financial() %>%
  dm_select_tbl(-trans) %>%
  collect()

fin_dm
``````

It is just as simple to move a local relational model into an RDBMS. 
Note that in the call to `copy_dm_to()` the argument `temporary = FALSE` is supplied. 
Without this argument the model would still be copied into the database, but the argument would default to `temporary = TRUE` and the data would be deleted once your session ends. 

``````{r }
destination_db <- DBI::dbConnect(RSQLite::SQLite())

deployed_dm <-
  copy_dm_to(destination_db, fin_dm, temporary = FALSE)

deployed_dm
fin_dm
``````

In the output you can observe that the `src` for `deployed_dm` is SQLite, while for `fin_dm` the source is not indicated -- it is a local data model.

Copying a relational model into an empty database is the simplest use case for `copy_dm_to()`.
If you want to copy a model into an RDBMS that is already populated, be aware that `copy_dm_to()` will not overwrite pre-existing tables.
In this case you will need to use the `table_names` argument to give the tables unique names.

`table_names` can be a named character vector, with the names matching the table names in the dm object and the values containing the desired names in the RDBMS, or a function or one-sided formula.
In the example below, `paste0()` is used to add a prefix to the table names to provide uniqueness.

``````{r }
dup_dm <-
  copy_dm_to(destination_db, fin_dm, temporary = FALSE, table_names = ~ paste0("dup_", .x))

dup_dm
dup_dm$accounts
deployed_dm$accounts
``````

Note the first line of the output for `dup_dm$accounts`.
The table name is `accounts` in the dm but it is backed by the table `dup_accounts` in the RDBMS.
`dm_deployed$accounts` shows us that this table is still backed by the `accounts` table from the `copy_dm_to()` operation we performed in the preceding example.

Managing tables in the RDBMS is outside the scope of `dm`. 
If you find you need to remove tables or perform operations directly on the RDBMS, see the [{DBI}](https://www.r-dbi.org/) package.

## Persisting individual tables

After adding columns to create links between tables or adding tables after calculating summaries of data, you might want the changes to your relational model to persist.

To force a dm to execute the SQL query generated by the operations it has performed, we call the `dplyr::compute()` method on the dm object.
`compute()` forces the computation of a query and stores the results in temporary tables on the RDBMS. 

In the example below, the multiple operations performed on `my_dm_sqlite` result in multiple queries created by {dm}.
These queries are lazily evaluated.
To fully evaluate the queries and collect the full result set, `compute()` is used.
If you want results to persist across sessions in permanent tables, `compute()` must be called with the argument `temporary = FALSE` and a table name for the `name` argument.
See the `compute()` documentation for more details.

Calling `compute()` requires write access, otherwise an error is returned.
The following examples will continue to use `deployed_dm` as it is hosted on SQLite with full permissions.

We start by creating a summary table that totals the loans for each account.

``````{r }
my_dm_total <-
  deployed_dm %>%
  dm_zoom_to(loans) %>%
  group_by(account_id) %>%
  summarize(total_amount = sum(amount, na.rm = TRUE)) %>%
  ungroup() %>%
  dm_insert_zoomed("total_loans")

my_dm_total$total_loans
``````

Context is set to the table "loans" using `dm_zoom_to(loans)`.
You can learn more about zooming in the tutorial `vignette("tech-dm-zoom")`.
We then use {[dplyr](https://dplyr.tidyverse.org/)} functions on the zoomed table to generate a new summary table.

`summarize()` returns a temporary table with one row for each group created by the preceding `group_by()` function.
The columns in the temporary table are constrained to the columns passed as arguments to the `group_by()` function and the column(s) created by the `summarize()` function.  

`dm_insert_zoomed("total_loans")` adds the temporary table created by `summarize()` to the data model under a new name, `total_loans`.

Two {[dplyr](https://dplyr.tidyverse.org/)} verbs have been implemented for dm objects.
`compute()` materializes all tables into new (temporary or persistent) tables.

``````{r }
my_dm_total_computed <-
  my_dm_total %>%
  compute()

my_dm_total_computed$total_loans

my_dm_total_computed$total_loans %>%
  sql_render()

my_dm_total$total_loans %>%
  sql_render()
``````

Note the differences in queries returned by `dbplyr::sql_render()`.
`my_dm_total$total_loans` is still being lazily evaluated and the full query constructed from the chain of operations that generated it, and is required to run if we want to access it, is still in place.
Contrast that with `my_dm_total_computed$total_loans` where the query has been realized and accessing its rows requires a simple `SELECT *` statement.
The table name, ` `r strsplit(remote_name(my_dm_total_computed$total_loans), " ")` `, was automatically generated as the `name` argument was not supplied.

`compute()` also works for a zoomed dm.
Calling it during a chain of operations will execute all relevant SQL queries up to that point.
Operations after the `compute()` will use the generated results.


``````{r }
my_dm_total_inplace <-
  deployed_dm %>%
  dm_zoom_to(loans) %>%
  group_by(account_id) %>%
  summarize(total_amount = sum(amount, na.rm = TRUE)) %>%
  ungroup() %>%
  compute() %>%
  dm_insert_zoomed("total_loans")

my_dm_total_inplace$total_loans %>%
  sql_render()
``````


## Conclusion

`dm` makes it straightforward to deploy your complete relational model to an RDBMS using the `copy_dm_to()` function. For tables that are created from a relational model during analysis or development, `compute()` can be used to persist them between sessions.

## Next steps

If you need finer-grained control over modifications to your relational model, see `vignette("howto-dm-rows")` for an introduction to row level operations, including updates, insertions, deletions and patching.

If you feel you need to know more about relational data models in order to get the most out of dm, check out `vignette("howto-dm-theory")`.

If you're familiar with relational data models but want to know how to work with them in dm, then any of `vignette("tech-dm-join")`, `vignette("tech-dm-filter")`, or `vignette("tech-dm-zoom")` is a good next step.
