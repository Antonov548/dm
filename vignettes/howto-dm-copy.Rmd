---
title: "Copying a dm into an RDBMS"
date: "`r Sys.Date()`"
author: James Wondrasek, Kirill MÃ¼ller
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{How to: Move a dm object into a database}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---


``````{r setup, include = FALSE}
source("setup/setup.R")
``````


In this tutorial we introduce {dm} methods and techniques for copying individual tables and entire relational data models into an RDBMS.
This is an integral part of the {dm} workflow.
Copying tables to an RDBMS is often a step in the process of building a relational data model from locally hosted data.
If your data model is complete, copying it to an RDBMS in a single operation allows you to leverage the power of the database and make it accessible to others.
For modifying and persisting changes to your model at the row-level see `vignette("howto-dm-rows")`.

## Copy models or copy tables?

Using {dm} you can persist an entire relational data model with a single function call.
`copy_dm_to()` will move your entire model into a destination RDBMS.
This may be all you need to deploy a new model.
#FIXME add links, make one para
You may want to add new tables to an existing model on an RDBMS.
Or your resource constraints might require transferring tables individually.
These requirements can be handled using the `compute()` and `copy_to()` methods.

Considerations for which approach to use depend on a number of factors. 
For newly created relational models those factors are the size of your model and network bandwidth.
For models that are updates to existing models on an RDBMS, deciding factors are the size of the changes and their complexity. 

## Copying and persisting individual tables {#copying-tables}

As part of your data analysis you may create links between tables by adding foreign key columns or create new tables holding data summaries.
You might want the changes to your relational data model to persist.

In the example below, the multiple operations performed on `my_dm_sqlite` to create a summary table result in multiple queries being created by {dm}.
These queries are lazily evaluated and unless requested otherwise {dm} returns a limited result set.
To force a dm to execute the SQL query generated by the methods called on it and return the full result set, you use the `dplyr::compute()` method.
`compute()` forces the computation of a query and stores the full results in temporary tables on the RDBMS. 

If you want results to persist across sessions in permanent tables, `compute()` must be called with the argument `temporary = FALSE` and a table name for the `name` argument.
See the `compute()` documentation for more details.

Calling `compute()` requires write permission on the RDBMS, otherwise an error is returned.
Therefore for the following examples we will instantiate a test dm and move it into a local SQLite database with full permissions.
The steps for this will be discussed in more detail when they are revisited in the [Copying a relational model](#copy-model) section.

``````{r }
library(dm)
library(dplyr)
library(dbplyr)

fin_dm <-
  dm_financial() %>%
  dm_select_tbl(-trans) %>%
  collect()

local_db <- DBI::dbConnect(RSQLite::SQLite())
deployed_dm <- copy_dm_to(local_db, fin_dm, temporary = FALSE)

``````

For this example we call {dm} methods on `deployed_dm` that create a new table.

``````{r}
my_dm_total <-
  deployed_dm %>%
  dm_zoom_to(loans) %>%
  group_by(account_id) %>%
  summarize(total_amount = sum(amount, na.rm = TRUE)) %>%
  ungroup() %>%
  dm_insert_zoomed("total_loans")

my_dm_total$total_loans
``````

Context is set to the table "loans" using `dm_zoom_to(loans)`.
You can learn more about zooming in the tutorial `vignette("tech-dm-zoom")`.
We then use {[dplyr](https://dplyr.tidyverse.org/)} functions on the zoomed table to generate a new summary table.

`summarize()` returns a temporary table with one row for each group created by the preceding `group_by()` function.
The columns in the temporary table are constrained to the columns passed as arguments to the `group_by()` function and the column(s) created by the `summarize()` function.  

`dm_insert_zoomed("total_loans")` adds the temporary table created by `summarize()` to the data model under a new name, `total_loans`.

When called on a dm object, `compute()` materializes all tables into new (temporary or persistent) tables by executing the associated SQL query and storing the full results.

``````{r }
my_dm_total_computed <-
  my_dm_total %>%
  compute()

my_dm_total_computed$total_loans

my_dm_total_computed$total_loans %>%
  sql_render()

my_dm_total$total_loans %>%
  sql_render()
``````

Note the differences in queries returned by `dbplyr::sql_render()`.
`my_dm_total$total_loans` is still being lazily evaluated and the full query constructed from the chain of operations that generated it, and is required to run to access it, is still in place.
Contrast that with `my_dm_total_computed$total_loans` where the query has been realized and accessing its rows requires a simple `SELECT *` statement.
The table name, ` `r strsplit(remote_name(my_dm_total_computed$total_loans), " ")` `, was automatically generated as the `name` argument was not supplied.

`compute()` also works for a zoomed dm (see `vignette("tech-dm-zoom")` to learn about zooming).
Calling it during a chain of operations will execute all relevant SQL queries up to that point.
Operations after the `compute()` will use the generated results.


``````{r }
my_dm_total_inplace <-
  deployed_dm %>%
  dm_zoom_to(loans) %>%
  group_by(account_id) %>%
  summarize(total_amount = sum(amount, na.rm = TRUE)) %>%
  ungroup() %>%
  compute() %>%
  dm_insert_zoomed("total_loans")

my_dm_total_inplace$total_loans %>%
  sql_render()
``````


## Adding local data frames to an RDBMS {#data-frames}

If you need to add local data frames to an existing database use the `copy_to()` method.
It takes the same arguments as `copy_dm_to()`, except the second argument takes a data frame rather than a dm.

To demonstrate the use of `copy_to()` the example below will use {dm} to pull consolidated data from several tables out of an RDBMS, estimate a linear model from the data, then insert the residuals back into the RDBMS and link it to the existing tables.

This is all done with a local SQLite database, but the process would work unchanged on any supported RDBMS.

Please note the used of `dm_squash_to_tbl()`.
This method gathers all linked information into a single wide table.
It follows foreign key relations starting from the table supplied as its argument and gathers all the columns from related tables, disambiguating column names as it goes.

``````{r}
loans_df <-
  deployed_dm %>%
  dm_squash_to_tbl(loans) %>%
  select(id, amount, duration, A3) %>%
  collect()

``````

In the above code, the `select()` statement isolates the columns we need for our model.
`collect()` works similarly to `compute()` by forcing the execution of the underlying SQL query, but it returns the results as a local tibble.

Below, the local tibble, `loans_df`, is used to estimate the linear model and the residuals are stored along with the original associated `id` in a new tibble, `loans_residuals`.
The `id` column is necessary to link the new tibble to the tables in the dm it was collected from.
Adding `loans_residuals` to the dm is done using `copy_to()`.
The call to the method includes the argument `temporary = FALSE` because we want this table to persist beyond our current session.
In the same pipeline we create the ncessary primary and foreign keys to integrate the table with the rest of our relational model.
For more information on key creation see `vignette("howto-dm-db")` and `vignette("howto-dm-theory")`.

``````{r}

model <- lm(amount ~ duration + A3, data = loans_df)

loans_residuals <- tibble::tibble(
  id = loans_df$id,
  resid = unname(residuals(model))
)

my_dm_sqlite_resid <-
  copy_to(deployed_dm, loans_residuals, temporary = FALSE) %>%
  dm_add_pk(loans_residuals, id) %>%
  dm_add_fk(loans_residuals, id, loans)

my_dm_sqlite_resid %>%
  dm_draw()
my_dm_sqlite_resid %>%
  dm_examine_constraints()
my_dm_sqlite_resid$loans_residuals

``````


## Persisting a relational model with `copy_dm_to()` {#copy-model}

Persistence, because it is intended to make permanent changes, requires write access to the source RDBMS.
To enable you to execute the examples in this tutorial SQLite will be used and all operations will be performed locally. 
{dm} is designed so there is no difference between the code used to manipulate a local SQLite database and a remote RDBMS.

The code below is a repeat of the code that opened the [Copying and persisting individual tables](#copying-tables) section at the beginning of the tutorial. 
It uses the {dm} convenience function `dm_financial()` (introduced in the previous tutorial, `vignette("howto-dm-load")`) to pull a model from a public dataset repository. 
`dm_select_tbl()` is used to exclude the transaction table, `trans` due to its size, then the `collect()` method retrieves the remaining tables and returns them as a local dm object.

``````{r }

fin_dm <-
  dm_financial() %>%
  dm_select_tbl(-trans) %>%
  collect()

fin_dm
``````

It is just as simple to move a local relational model into an RDBMS. 

``````{r }
destination_db <- DBI::dbConnect(RSQLite::SQLite())

deployed_dm <-
  copy_dm_to(destination_db, fin_dm, temporary = FALSE)

deployed_dm
fin_dm
``````

Note that in the call to `copy_dm_to()` the argument `temporary = FALSE` is supplied. 
Without this argument the model would still be copied into the database, but the argument would default to `temporary = TRUE` and the data would be deleted once your session ends. 

In the output you can observe that the `src` for `deployed_dm` is SQLite, while for `fin_dm` the source is not indicated because it is a local data model.

Copying a relational model into an empty database is the simplest use case for `copy_dm_to()`.
If you want to copy a model into an RDBMS that is already populated, be aware that `copy_dm_to()` will not overwrite pre-existing tables.
In this case you will need to use the `table_names` argument to give the tables unique names.

`table_names` can be a named character vector, with the names matching the table names in the dm object and the values containing the desired names in the RDBMS, or a function or one-sided formula.
In the example below, `paste0()` is used to add a prefix to the table names to provide uniqueness.

``````{r }
dup_dm <-
  copy_dm_to(destination_db, fin_dm, temporary = FALSE, table_names = ~ paste0("dup_", .x))

dup_dm
dup_dm$accounts
deployed_dm$accounts
``````

Note the first line of the output for `dup_dm$accounts`.
The table name is `accounts` in the dm but it is backed by the table `dup_accounts` in the RDBMS.
`dm_deployed$accounts` shows us that this table is still backed by the `accounts` table from the `copy_dm_to()` operation we performed in the preceding example.

Managing tables in the RDBMS is outside the scope of `dm`. 
If you find you need to remove tables or perform operations directly on the RDBMS, see the [{DBI}](https://www.r-dbi.org/) package.

## Conclusion

`dm` makes it straightforward to deploy your complete relational model to an RDBMS using the `copy_dm_to()` function. For tables that are created from a relational model during analysis or development, `compute()` and `copy_to()` can be used to persist them between sessions.

Moving individual data frames into a dm hosted on an RDBMS and integrating it into an existing relational model has also been demonstrated.
The `copy_to()` method is used to perform transfer, after which the full suite of {dm} methods is available to create keys, check constraints, and incorporate new tables into normal operations.

## Next steps

If you need finer-grained control over modifications to your relational model, see `vignette("howto-dm-rows")` for an introduction to row level operations, including updates, insertions, deletions and patching.

If you feel you need to know more about relational data models in order to get the most out of dm, check out `vignette("howto-dm-theory")`.

If you're familiar with relational data models but want to know how to work with them in dm, then any of `vignette("tech-dm-join")`, `vignette("tech-dm-filter")`, or `vignette("tech-dm-zoom")` is a good next step.
