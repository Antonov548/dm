---
title: "Persisting rows of a dm"
date: "`r Sys.Date()`"
author: James Wondrasek
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{How to: Create a dm object from a database}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---


``````{r setup, include = FALSE}
source("setup/setup.R")
``````

## dm functions for persisting rows

`dm` stands on the shoulders of {dplyr} to provide functions that allow you to specify which rows, and the columns within those rows, you would like to persist on the RDBMS.
Following SQL nomenclature, these functions are named around `dm_rows_insert()` for adding new rows, and `d,_rows_update()` for making changes to existing rows.

The functions require that the rows to be inserted or updated are in a table compatible with the destination table.
For rows being updated, only the columns being updated need to be included in the table, but the primary key column must be present and the ids in that column must be present in the destination table.

For inserting rows it is easiest to start with an empty table with the appropriate structure and populate it with new data before persisting the rows on the RDBMS.
To make this easy, dm has the `dm_ptype()` function.
`dm_ptype()` strips the data from a dm and returns the dm with the tables intact but empty.

As in the previous tutorial, `vignette("howto-dm-copy")`, we start by using a convenience function to load a dm with a relational model.

``````{r }
dm_sqlite <- dm_financial_sqlite()
dm_sqlite
dm_nrow(dm_sqlite)

dm_empty <- dm_ptype(my_dm_sqlite)
dm_empty
dm_nrow(dm_empty)
``````

Note the Table Source portion when printing each of the dm objects.
`dm_empty` is now local and the tables are backed by tibbles.

We will now create a row to insert in the `accounts` table. 
As `dm_rows_insert()` requires primary keys to be unique, we will first find the current maximum primary key and start our numbering beyond that. 

``````{r }
library(dplyr)

#FIXME - this seems really inefficient. Is there a cleaner way to get the max value in a column?
new_id <- 
  dm_sqlite$accounts %>% 
  summarize(new_id = max(id, na.rm = TRUE) + 1L) %>% 
  pull()
``````

Next, we will use {dplyr}'s `add_row()` to create a new account entry.
`add_row()` returns a new tibble.
This requires us to remove the current, empty `account` table from the dm object and add the copy containing our new data to the dm object in its place.

```````{r }
#FIXME and here is my naive attempt to get a row into a table in dm. What's a more idiomatic way to do this?
new_account <- tibble(id = 11383, district_id = 18, frequency = "dummy", date = 9736)
dm_data <- dm(accounts = new_account)

``````

