% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/persist-dm.R
\name{persist-dm}
\alias{persist-dm}
\alias{dm_insert}
\title{Persisting data for multiple tables}
\usage{
dm_insert(target_dm, dm, ..., persist = FALSE)
}
\arguments{
\item{target_dm}{Target \code{dm} object.}

\item{dm}{\code{dm} object with new data.}

\item{...}{Must be empty.}

\item{persist}{Set to \code{TRUE} for running the operation without persisting.
In this mode, a modified version of \code{target_dm} is returned.
This allows verifying the results of an operation before actually
applying it.
Set to \code{FALSE} to perform the update on the database table.
By default, an informative message is shown.}
}
\value{
A dm object of the same \code{\link[=dm_ptype]{dm_ptype()}} as \code{target_dm}.
If \code{persist = TRUE}, \link{invisible} and identical to \code{target_dm}.
}
\description{
\lifecycle{experimental}

These functions provide a framework for updating data in existing tables.
Unlike \code{\link[=compute]{compute()}}, \code{\link[=copy_to]{copy_to()}} or \code{\link[=copy_dm_to]{copy_dm_to()}}, no new tables are created
on the database.
All operations expect that both existing and new data are presented
in two compatible \link{dm} objects on the same data source.

The functions make sure that the tables in the target dm
are processed in topological order so that parent (dimension)
tables receive insertions before child (fact) tables.

These operations, in contrast to all other operations,
may lead to irreversible changes to the underlying database.
Therefore, persistence must be requested explicitly with \code{persist = TRUE}.
By default, an informative message is given.

\code{dm_insert()} adds new records.
The primary keys must differ from existing records.
This must be ensured by the caller and might be checked by the underlying database.
Use \code{persist = FALSE} and apply \code{\link[=dm_examine_constraints]{dm_examine_constraints()}} to check beforehand.
}
\examples{
if (rlang::is_installed("RSQLite")) {
  # Entire dataset with all dimension tables populated
  # with flights and weather data truncated:
  flights_init <-
    dm_nycflights13() \%>\%
    dm_zoom_to(flights) \%>\%
    filter(FALSE) \%>\%
    dm_update_zoomed() \%>\%
    dm_zoom_to(weather) \%>\%
    filter(FALSE) \%>\%
    dm_update_zoomed()

  sqlite <- src_sqlite(":memory:", create = TRUE)

  # Target database:
  flights_sqlite <- copy_dm_to(sqlite, flights_init, temporary = FALSE)
  print(dm_nrow(flights_sqlite))

  # First update:
  flights_jan <-
    dm_nycflights13() \%>\%
    dm_select_tbl(flights, weather) \%>\%
    dm_zoom_to(flights) \%>\%
    filter(month == 1) \%>\%
    dm_update_zoomed() \%>\%
    dm_zoom_to(weather) \%>\%
    filter(month == 1) \%>\%
    dm_update_zoomed()
  print(dm_nrow(flights_jan))

  # Copy to temporary tables on the target database:
  flights_jan_sqlite <- copy_dm_to(sqlite, flights_jan, unique_table_names = TRUE)

  # Dry run by default:
  dm_insert(flights_sqlite, flights_jan_sqlite)
  print(dm_nrow(flights_sqlite))

  # Explicitly request persistence:
  dm_insert(flights_sqlite, flights_jan_sqlite, persist = TRUE)
  print(dm_nrow(flights_sqlite))

  # Second update:
  flights_feb <-
    dm_nycflights13() \%>\%
    dm_select_tbl(flights, weather) \%>\%
    dm_zoom_to(flights) \%>\%
    filter(month == 2) \%>\%
    dm_update_zoomed() \%>\%
    dm_zoom_to(weather) \%>\%
    filter(month == 2) \%>\%
    dm_update_zoomed()

  # Copy to temporary tables on the target database:
  flights_feb_sqlite <- copy_dm_to(sqlite, flights_feb, unique_table_names = TRUE)

  # Explicit dry run:
  flights_new <- dm_insert(
    flights_sqlite,
    flights_feb_sqlite,
    persist = FALSE
  )
  print(dm_nrow(flights_new))
  print(dm_nrow(flights_sqlite))

  # Check for consistency before applying:
  flights_new \%>\%
    dm_examine_constraints()

  # Apply:
  dm_insert(flights_sqlite, flights_feb_sqlite, persist = TRUE)
  print(dm_nrow(flights_sqlite))
}
}
