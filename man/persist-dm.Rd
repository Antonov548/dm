% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/persist-dm.R
\name{persist-dm}
\alias{persist-dm}
\alias{dm_insert}
\title{Persisting data for multiple tables}
\usage{
dm_insert(target_dm, dm, ..., dry_run = FALSE)
}
\arguments{
\item{target_dm}{Target dm object.}

\item{dm}{dm object with new data.}

\item{...}{Must be empty.}

\item{dry_run}{Set to \code{TRUE} for running the operation without persisting.
In this mode, a modified version of \code{target_dm} is returned.
This allows verifying the results of an operation before actually
applying it.}
}
\value{
A dm object of the same \code{\link[=dm_ptype]{dm_ptype()}} as \code{target_dm},
visible only if \code{dry_run = TRUE}, otherwise \link{invisible}.
Identical to \code{target_dm} when run on a database with \code{dry_run = FALSE}.
}
\description{
\lifecycle{experimental}

These functions provide a framework for updating data in existing tables.
Unlike \code{\link[=compute]{compute()}}, \code{\link[=copy_to]{copy_to()}} or \code{\link[=copy_dm_to]{copy_dm_to()}}, no new tables are created
on the database.
All operations expect that both existing and new data are presented
in two compatible \link{dm} objects on the same data source.

The tables in the target dm are ordered topologically
so that parent (dimension) tables receive insertions
before child (fact) tables.

\code{dm_insert()} adds new records.
The primary keys must differ from existing records.
}
\examples{
if (rlang::is_installed("RSQLite")) {
  # Entire dataset with all dimension tables populated
  # with flights and weather data truncated:
  flights_init <-
    dm_nycflights13() \%>\%
    dm_zoom_to(flights) \%>\%
    filter(FALSE) \%>\%
    dm_update_zoomed() \%>\%
    dm_zoom_to(weather) \%>\%
    filter(FALSE) \%>\%
    dm_update_zoomed()

  sqlite <- src_sqlite(":memory:", create = TRUE)

  # Target database:
  flights_sqlite <- copy_dm_to(sqlite, flights_init, temporary = FALSE)
  print(dm_nrow(flights_sqlite))

  # First update:
  flights_jan <-
    dm_nycflights13() \%>\%
    dm_select_tbl(flights, weather) \%>\%
    dm_zoom_to(flights) \%>\%
    filter(month == 1) \%>\%
    dm_update_zoomed() \%>\%
    dm_zoom_to(weather) \%>\%
    filter(month == 1) \%>\%
    dm_update_zoomed()
  print(dm_nrow(flights_jan))

  # Copy to temporary tables on the target database:
  flights_jan_sqlite <- copy_dm_to(sqlite, flights_jan, unique_table_names = TRUE)
  dm_insert(flights_sqlite, flights_jan_sqlite)
  print(dm_nrow(flights_sqlite))

  # Second update:
  flights_feb <-
    dm_nycflights13() \%>\%
    dm_select_tbl(flights, weather) \%>\%
    dm_zoom_to(flights) \%>\%
    filter(month == 2) \%>\%
    dm_update_zoomed() \%>\%
    dm_zoom_to(weather) \%>\%
    filter(month == 2) \%>\%
    dm_update_zoomed()

  # Copy to temporary tables on the target database:
  flights_feb_sqlite <- copy_dm_to(sqlite, flights_feb, unique_table_names = TRUE)

  # Dry run:
  flights_new <- dm_insert(
    flights_sqlite,
    flights_feb_sqlite,
    dry_run = TRUE
  )
  print(dm_nrow(flights_new))
  print(dm_nrow(flights_sqlite))

  # Check for consistency before applying:
  flights_new \%>\%
    dm_examine_constraints()

  # Apply:
  dm_insert(flights_sqlite, flights_feb_sqlite)
  print(dm_nrow(flights_sqlite))
}
}
